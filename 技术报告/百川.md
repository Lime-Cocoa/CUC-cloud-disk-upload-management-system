# ☁️中传放心传（CUC-cloud-disk-upload-management-system）技术报告

**一个基于Vue和springboot+mybatisplus实现的文件云盘管理系统**

[![Typing SVG](https://readme-typing-svg.herokuapp.com?size=30&duration=1497&center=%E9%94%99%E8%AF%AF%E7%9A%84&vCenter=%E9%94%99%E8%AF%AF%E7%9A%84&multiline=true&width=620&height=70&lines=%E4%B8%AD%E4%BC%A0%E6%94%BE%E5%BF%83%E4%BC%A0;CUC-cloud-disk-upload-management-system)](https://git.io/typing-svg)

**作者**：百川🌊

**负责工作**：项目整体规划、前端页面编写、后端平台搭建、网站部署、具体功能修复测试

**时间**：2022.8

**前端工作日志**：[前端开发日志](https://github.com/Xuyan-cmd/CUC-cloud-disk-upload-management-system/blob/front_end/README.md)

**后端工作日志**：[后端开发日志](https://github.com/Xuyan-cmd/CUC-cloud-disk-upload-management-system/blob/front_end/README.md)

💽**系统功能操作视频演示地址:**[操作视频演示地址](https://reurl.cc/5ppvGq)

💭**项目在线地址**：http://119.23.64.32/

🎆**项目域名**：http://www.cucinstall.cn/ （目前还在备案中。。。。。）

## 前言

本次小学期的实践目标是实现一个结合本专业密码学和网络安全知识体系的一个文件管理云盘系统，要求做到有文件管理的基础功能（增删改查）以外还要融入网络空间安全专业所特有的专业知识，是一次十分有意义的并且能够挖掘自身能力和一个深度学习的过程。

对于我而言，这一个多月的开发时间里，我遇到了很多的困难和知识盲区，但在这样持续学习的一个过程中，我能够深刻意识到自己对于很多知识的匮乏，因此也是这样一个契机带动着我去学习和摸索。

在最初的计划阶段，我的设想是基于老师给出的模板进行开发，但是和小组成员进行了讨论后，大家更愿意借助这样一段时间去从0开始去搭建开发，于是我们去查阅相关资料，结合我们现有的知识储备，最终决定使用当前市场主流的开发框架和工具，前端采用当前较为火遍的**Vue框架**，后端使用近几年的新锐**SpringBoot框架**。而在具体开发过程中结合密码学知识基础和要求去完成这样一个云盘文件管理系统——**中传放心传**

我对于前端开发所使用的Vue框架有一定的基础，而对于后端的接口逻辑编写和搭建只知皮毛，因此我们小组在后端的开发过程中花费相当大的学习成本，这中间出现了很多Bug和技术壁垒，我一度曾怀疑我们是否有能力在这样短的时间内去完成这样的开发，但感谢我的组员，我们始终没有退缩，最终真的从0到完整开发出成品！虽然存在很多不完美的地方和有待商榷的技术细节，但对于我们小组每一个人而言，这段时间的学习和实践是本次暑期小学期最大的收获和意义！

## 开发内容回顾

在这个章节，我主要列出了我在整个开发过程中印象深刻的一些内容，包括部分问题的解决思路、知识学习回顾、Bug修复的方法。

**项目主体开发思路框架：**![](https://s6.jpg.cm/2022/08/03/PQMxgX.jpg)

### 前端开发

- **对于用户注册口令信息的密码强度校验和规则设定**
  
  - 为了确保用户注册时口令信息的安全强度，因此需要直接在用户注册时对其口令进行校验和规则设定，因此我选择结合element-ui的form表单工具和正则表达式去实现这样的功能逻辑，例如项目中我设定了用户的用户名限制在11位，口令长度8-36，其中口令只接受阿拉伯数字、英文字母、除-、_\、以外的字符，通过正则表达式去限制具体的内容。
  
  - ```typescript
    <el-form-item>
     <el-input
        v-model="registered.password"
        @input="checkPassLever"
        type="password"
        placeholder="请输入密码"
        onkeyup="value=value.replace(/[^\a-\z\A-\Z0-9\-\_\.]/g,'')"
        maxlength="36"
        minlength="8"
        show-word-limit
        ></el-input>
    ```

- **前端页面路由跳转问题的分析**
  
  - 在开发前端页面过程中，出现了对于路由设定的问题，当按返回键的时候页面并没有发生变化，一开始还以为是没有监听到返回事件，但是通过测试之后发现返回事件监听成功了，路由也发生了变化，相应事件也触发了，就是页面视图没有跟着改变。
  
  - 原因分析：项目中路由设置的是 **hash模式**，所以对 hashchange 事件进行监听hash模式下，路由的变化会触发hashchange事件）。因此要重新在app.vue文件中重新绑定路由，从而路由不会因为重复调用而导致不能改变视图。
    
    - ```typescript
       mounted() {
          // 检测浏览器路由改变页面不刷新问题,hash模式的工作原理是 hashchange事件
          window.addEventListener('hashchange', () => {
          let currentPath = window.location.hash.slice(1)
          if (this.$route.path !== currentPath) {
            this.$router.push(currentPath)
          }
        }, false)
      }
      ```

- **使用axios访问api时出现的问题**
  
  - **axios使用post请求服务端不能获取参数的解决方法**：
  
  - 项目中使用到axios作为ajax请求插件，用到post请求是常见的，但是后台说没有接收到传过去的参数，但是可以收到请求，前端检查了好几遍，浏览器的请求信息是 OK 的，请求封装也是ok的，参数都是有的，前端看是服务端的问题，服务端监测是前端的问题，这就十分抓狂。
  
  - 其实是axios在内部自动帮我们转换json格式数据, 也就是说，我们的 Content-Type 变成了 application/json;charset=utf-8
    然后，因为我们的参数是 JSON 对象，axios 帮我们做了一个 stringify 的处理。 而axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。
    那么，这就与我们服务端要求的 ‘Content-Type’: ‘application/x-www-form-urlencoded’ 不符合。
    
    首先我尝试了给axios 头添加post请求方法的 Content-Type：
    
    ```typescript
    axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 
    ```
    
    但是并没有起效果，翻了半天文档又查了一下需要序列化, qs序列化请求参数即可，当然你可以在封装请求方法的api中每次请求时作处理，我这里使用了封装axios时直接在request请求拦截器中做了处理：
    
    ```typescript
    import Qs from 'qs'
    axios.interceptors.request.use( (config) => {
        if (config.method=="post"){
            config.data = qs.stringify(config.data);
            config.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }
        return config;
    },  (error) => {
        return Promise.reject(error);
    });
    ```
    
    最后成功发送post请求，得到数据。
  
  - **使用axios，get数据是正常的。但是渲染数据时data一直为空解决方案：**
  
  - 原因;在ajax中的this会指向ajax本身，而不再是vue实例本身 ，同理，axios的then中this也不是指向vue实例本身。
    
    - **方法1：** 用ES6箭头函数，箭头方法可以和父方法共享变量 ( ES6中的 箭头函数 “=>” 内部的this是词法作用域，由上下文确定(也就是由外层调用者vue来确定) )
    
    - ```typescript
      axios({
                  method:'get',
                  url:'/api/info'
                })
              .then((response) => {
                console.log(response.data)
                that.listClass = response.data
              }).catch((error) => { // 请求失败处理
              console.log(error);
            });
      ```
  
  - **方法2：** 在请求axios外面定义一下 var that=this
    
    - ```typescript
      //用axios获取数据
            var that = this
            axios({
                  method:'get',
                  url:'/api/info'
                })
              .then(function(response){
                console.log(response.data)
                that.listClass = response.data
              }).catch(function(error){ // 请求失败处理
              console.log(error);
            });
      ```
      
      **参考**：[axios官方文档](http://axios-js.com/zh-cn/docs/index.html)

- **如何优雅的只在当前页面中覆盖ui库中组件的样式**
  
  - 熟悉webpack的人应该知道，引入的CSS文件最终都会被style-loader处理。简单来说，它的作用就是把CSS文件打包，放在style标签内，最后塞进HTML中作为一个内部样式表。不管是组件库的样式还是我们写的自定义样式都是这样处理的。
  
  - ![](https://s6.jpg.cm/2022/08/04/PdGEZX.jpg)
  
  - 我们要把组件库的样式先于自定义样式引入，这样自定义样式才能有更高的优先级。
  
  - 直接改组件库的CSS源码是最简单粗暴的方法。打开你项目的node_modules文件夹，一层层点开，找到对应样式文件，按照需求修改即可。个人项目这样处理确实可行，但是团队合作时，同步别人本地的node_modules就比较麻烦，只能算一个60分解法。
  
  - **全局CSS文件**
    
    之前提到，把自己写的的CSS文件放在组件库的样式后面，可以保障自定义有更高优先级。只要重写同名的样式，理论上就能实现覆盖组了。
    
    但这样👇处理会发现并不起作用：
    
    ```css
    /* src/demo.css */
    .ant-picker-calendar-date-today {
      border-color: purple; /* 覆盖为紫色 */
    }
    ```
    
    ```css
    // src/Demo.js
    
    // 组件库的样式
    import 'ant-design-vue/dist/antd.css'; 
    // 自定义样式
    import './demo.css'
    import { Calendar } from 'antd';
    ...
    <div className="myWrapper">
      <Calendar />
    </div>
    ```
    
    因为这里还涉及CSS组合选择器的优先级。
    
    基础的优先级应该不用赘述：`!important>内联样式>ID选择器>类选择器>标签选择器`。（!important这种hack会导致项目不好维护，不提倡使用）
    
    在这个基础上还有五种组合选择器要对优先级分数做累计，以类选择器为例：
    
    1. 后代选择器（空格）：`.A .B`选择.A元素后的所有.B元素，
    2. 子元素选择器（大于号）：`.A>.B`选择.A元素的直接后代中的.B元素
    3. 相邻兄弟选择器（加号）：`.A+.B`选择.A元素后紧邻的第一个兄弟.B元素
    4. 后续兄弟选择器(~号)：`.A~.B`选择.A元素后所有的兄弟.B元素
    5. 交集选择器（连在一起）：`.A.B`选择自身同时拥有.A和.B两个属性的元素

- **本地开发环境请求服务器接口跨域的问题**
  
  - 前后端分离项目需要解决第一个问题就是，前端本地开发时如何解决通过ajax请求产生的跨域的问题。一般的做法是通过本地配置nginx反向代理进行处理的，除此之外，还可以通过nodejs来进行代理接口。当然，要实现这个前提是，前端开发环境必须运行在nodejs服务中，所幸的是，现在前端的开发自动化工具都是建立在nodejs上的，所以这个前提也不是很重要。
  
  - 跨域指浏览器不允许当前页面的所在的源去请求另一个源的数据。源指协议，端口，域名。只要这个3个中有一个不同就是跨域。 这里列举一个经典的列子：
  
  - ```bash
    #协议跨域
    http://a.baidu.com访问https://a.baidu.com；
    #端口跨域
    http://a.baidu.com:8080访问http://a.baidu.com:80；
    #域名跨域
    http://a.baidu.com访问http://b.baidu.com；
    ```
    
    解决方案：生产环境的话还是比较推荐`nginx`的
    
    - 比如后端地址为`http://localhost:8080/
      那么前端在代码里只需要访问`/mall_war/*.do`就可以，默认发的是部署服务器的`ip`来访问
      然后再`nginx`里配置如下
    
    - ```typescript
      server {
          listen       8080;
          server_name  commonFronted;
          # 项目静态资源目录
          location / {
              alias     /xxx/dist;
              index     index.html;
          }
      
          location ^~/mall_war/ {
              proxy_pass http://localhost:8089/mall_war/;
              proxy_set_header  Host $host;
              proxy_set_header  X-Real-IP $remote_addr;
              proxy_set_header  X-Forwarded-Proto https;
              proxy_set_header  X-NginX-Proxy true;
              proxy_buffers 256 4k;
              proxy_max_temp_file_size 0k;
              proxy_connect_timeout 30;
              proxy_send_timeout 60;
              proxy_read_timeout 60;
              proxy_next_upstream error timeout invalid_header http_502;            
          }
      }
      ```

- **Vue 项目中 icon 小图标不显示**
  
  - 在 HTML 文件中添加了以下代码后，发现小图标还是没能呈现，应该是 Vue 项目缺少生成配置的问题
  
  - ```html
    <head>
        <meta charset="utf-8">
        <meta name="author" content="author">
        <title>主页</title>
        <!-- 添加 favicon.ico 为网站图标(有在线.jpg, .png 文件转 .icon 工具) -->
        <link rel="Bookmark" type="image/x-icon" href="./src/assets/icon/favicon.ico" />
        <link rel="icon" type="image/x-icon" href="./src/assets/icon/favicon.ico" />
        <link rel="shortcut icon" type="image/x-icon" href="./src/assets/icon/favicon.ico" />
    </head>
    ```
    
    **解决办法：**
    
    在 `webpack.dev.conf.js`中新增一行 favicon 生成配置后，使用命令 `npm run dev` 重新启动 Vue 项目。
    
    ```typescript
    new HtmlWebpackPlugin({
          // 会自动帮你生成一个 html 文件，并且引用相关的 assets 文件(如 css, js)
          filename: 'index.html',
          // 根据自己的指定的模板文件来生成特定的 html 文件
          template: 'index.html',
          // 指定 script 位置, 默认为 true --- html 文件底部
          inject: true,
    
          // 给生成的 html 文件生成一个 favicon, 属性值为 favicon 文件所在的路径。
          favicon:'./src/assets/icon/favicon.ico'
    }),
    ```

- **组件中使用定时器及销毁问题**
  
  - 在页面开发过程中使用了一个定时器，当从页面A跳转到页面B时，如果不手动清除这个定时器，那么它仍旧会执行，会影响到后续的渲染效果。
    这里给出我的解决办法就是，在`data`属性中定义一个`timer`，在代码中启动定时器，然后在组件销毁的时候清除定时器。具体代码如下：、
  
  - ```typescript
        data(){
            return{
                timer:null
            }
        },
        methods:{
            onStartTimer(){
                this.timer = setInterval( () => {
                    // 执行一些操作
                }, 1000)
            }
        },
        beforeDestroy() {
            clearInterval(this.timer);        
            this.timer = null;
        }
    ```
    
    但是这里有两个潜在的问题：
    
    1. 它需要在这个组件实例中保存这个`timer`，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。
    2. 我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。
    
    `Vue`官方文档给出的解决方案是，在定义timer的时候使用`$once`指令监听`beforeDestroy`这个钩子函数。在这个基础上进行改进的话：
    
    ```typescript
        methods:{
            onStartTimer(){
                const timer = setInterval( () => {
                    // 执行一些操作
                }, 1000)
                this.$once('hook:beforeDestroy', () => {            
                    clearInterval(timer);                                    
                })
            }
        },
    ```
    
    这样就解决了上面所列的两个问题。类似的这种在离开页面时需要销毁的组件都可以采用此方法。

- **在前端开发过程中，发现报如下错误：`startvaluehas mixed support,considerusingflex-startinstead`**
  
  - 发现是因为CSS写法不规范导致的。之前的CSS弹性盒子模型写法是这样的：
    
    `div{display: flex;justify-content: start;}`
    
    <img src="https://s6.jpg.cm/2022/08/04/PdIcnQ.png" style="zoom: 67%;" />
  
  - 但是这种是很早的属性值了，新的属性值应该是flex-start，如下：
    
    <img src="https://s6.jpg.cm/2022/08/04/PdIUJh.png" style="zoom:67%;" />
  
  - 此致问题解决。
    
    ![](https://s6.jpg.cm/2022/08/04/PdI1IW.png)

- **Vue解决报错：Emitted value instead of an instance of Error问题**
  
  - **重现报错提示：**
    
    ```bash
    (Emitted value instead of an instance of Error) <van-cell v-for=" item in this.todoList">: component lists rendered with v-for should have explicit keys. See https://vuejs.org/guide/list.html#key for more info.
    ```
    
    由于上述警告造成Vue项目不能启动，警告的大概意思就是在组件里面使用v-for 但是没有设置key，会造成非唯一性问题。
    
    针对上述问题的解决方法：
    
    在警告的组件里面v-for后面加一个属性key，为元素绑定了一个key，`v-for="(item, index) in this.todoList" :key="index"` 的操作，即：
    
    ```typescript
    <van-cell
                  v-for="(item, index) in this.todoList" :key="index"
                   :to="{ name: 'Approval/Detail', params: { id: item.businessId } }"
                >
                  <van-icon name="bell" size="30" />
                  <div class="info-right">
                    <p class="user-info">{{ item.startBy }}</p>
                    <p class="place">{{ item.processInstanceName }}</p>
                  </div>
                </van-cell>
    ```
    
    ![](https://s6.jpg.cm/2022/08/04/PdIhU4.jpg)

- **音乐播放器组件的编写**
  
  - 我们项目考虑到用户上传文件中包含音频类文件，那么对于这类文件如果需要在线预览就需要去单独编写组件去读取数据。
  
  - 所以在编写音乐播放器组件的时候需要考虑几点，音频文件的播放进度回调，播放速度，进度条显示等因素，需要监听当前播放的音频文件的状态信息，例如暂停播放、进度条拖动、重新播放等状态变化
  
  - ```typescript
    watch: {
        // 监听vuex中的当前音频播放信息
        async "$store.state.currentMusicInfo"(current) {
          this.currentMusicInfo = current;
          if (this.$store.state.isMusicPlayerShow) {
            this.$store.state.isMusicPlayerShow = false;
            this.getAudioUrl();
            await this.$store.commit("updateIsMusicPlayerShow", true);
          }
        },
    
        // 监听当前音频播放状态
        "$store.state.musicPlayState"(current) {
          // 如果不相同 说明在组件之外有地方改变了播放状态，需要将播放状态更新至此组件
          if (current != this.playState) {
            this.playState = current;
            if (current) {
              this.$refs.currentMusicPlayer.play();
            } else {
              this.$refs.currentMusicPlayer.pause();
            }
          }
        },
      },
      filters: {
        handleTime,
      },
      mounted() {},
    };
    </script>
    ```
    
    最终即可做出一个简易的视频播放器组件：
    
    ![](https://s6.jpg.cm/2022/08/04/PdqMTH.png)

- **vue-router中query参数做自动加密、解密**
  
  - 加密需要依赖 `crypto-js` 库，安装：
  
  - ```bash
    npm install crypto-js --save
    ```
    
    1. 将`utils`文件夹放入项目 **（最好是放在router目录下 ）** 中，在router的初始化文件中，引入`utils/query.js`的`stringifyQuery`和`parseQuery`方法，在`new VueRouter`是时候传递参数，
    2. 修改`utils/encryption.js`中的`baseCryptoCode`设置每个项目唯一的值
    
    ```typescript
    import Vue from "vue"
    import VueRouter from "vue-router";
    import { stringifyQuery, parseQuery } from "./utils/query";
    
    Vue.use(VueRouter);
    
    const routes = [];
    
    const router = new VueRouter({
      mode: 'history',
      base: process.env.BASE_URL,
      stringifyQuery: stringifyQuery, // 序列化query参数
      parseQuery: parseQuery, // 反序列化query参数
      routes
    });
    
    export default router
    ```
    
    - tils/encryption.js
      
      文件提供加密和解密算法（默认在index.html中已经引入了crypto-js.js）
      
      - getEncrypt 加密 对应的解密方法（getDecrypt）
      - getEncryptToBase64 加密后转base64 对应的解密方法（getDecryptByBase64）
      - getDecrypt 解密 对应的加密方法（getEncrypt）
      - getDecryptByBase64 对base64数据解密 先解析base64，在做解密 对应的加密方法（getEncryptToBase64）
    
    - utils/query.js
      
      文件提供了序列化和反序列化的方法
      
      - stringifyQuery 序列化对象并 加密
      - parseQuery 解密 反序列化对象
    
    反序列化
    
    在调用`push`的时候，会执行`this.router.match`方法，`match`方法会执行`normalizeLocation`
    
    `normalizeLocation`通过`resolveQuery`方法解析path中的query，传入的三个参数（path中的?之后的参数数据字符串，使用push或replace方法传递的query参数，反序列化参数的方法）
    
    反序列化方法会通过`router && router.options.parseQuery`获取，如果在`new VueRouter`的时候传递了`parseQuery`方法，就是用该方法，如果没有就在`resolveQuery`方法中使用默认的方法
    
    ```typescript
    export function normalizeLocation (
      raw: RawLocation,
      current: ?Route,
      append: ?boolean,
      router: ?VueRouter
    ): Location {
      let next: Location = typeof raw === 'string' ? { path: raw } : raw
      // named target
      if (next._normalized) {
        return next
      } else if (next.name) {
        next = extend({}, raw)
        const params = next.params
        if (params && typeof params === 'object') {
          next.params = extend({}, params)
        }
        return next
      }
    
      // relative params
      if (!next.path && next.params && current) {
        next = extend({}, next)
        next._normalized = true
        const params: any = extend(extend({}, current.params), next.params)
        if (current.name) {
          next.name = current.name
          next.params = params
        } else if (current.matched.length) {
          const rawPath = current.matched[current.matched.length - 1].path
          next.path = fillParams(rawPath, params, `path ${current.path}`)
        } else if (process.env.NODE_ENV !== 'production') {
          warn(false, `relative params navigation requires a current route.`)
        }
        return next
      }
    
      const parsedPath = parsePath(next.path || '')
      const basePath = (current && current.path) || '/'
      const path = parsedPath.path
      ? resolvePath(parsedPath.path, basePath, append || next.append)
      : basePath
    
      const query = resolveQuery(
        parsedPath.query,
        next.query,
        router && router.options.parseQuery
      )
    
      let hash = next.hash || parsedPath.hash
      if (hash && hash.charAt(0) !== '#') {
        hash = `#${hash}`
      }
    
      return {
        _normalized: true,
        path,
        query,
        hash
      }
    }
    ```

### 后端开发

- **文件上传、下载、删除接口函数编写总结**
  
  - 文件的上传下载等借口，使用最多的两个类File以及MultipartFile类
  
  - **File类**
    
    ```java
    // 文件系统对象
    // 后面很多方法也用到了文件系统类的方法，比如系统创建文件的时间等，这里简称fs，后面多处都用到了
    private static final FileSystem fs = DefaultFileSystem.getFileSystem();
    
    // 路径名
    private final String path;
    
    // 枚举类型
    // file类对象的地址是否合法通过枚举类判定
    private static enum PathStatus { INVALID, CHECKED };
    
    // 文件路径是否有效
    private transient PathStatus status = null;
    // 检查路径是否有效 但只涉及nul字符，true绝对无效，false不一定有效
    final boolean isInvalid() {
        if (status == null) {
            status = (this.path.indexOf('\u0000') < 0) ? PathStatus.CHECKED
                                                       : PathStatus.INVALID;
        }
        return status == PathStatus.INVALID;
    }
    
    // 路径名前缀长度
    private final transient int prefixLength;
    int getPrefixLength() {
        return prefixLength;
    }
    
    // 依赖系统分隔符
    public static final char separatorChar = fs.getSeparator();
    // 将其转换为字符串表示
    public static final String separator = "" + separatorChar;
    ```
    
    | 函数                                       | 描述                     |
    | ---------------------------------------- | ---------------------- |
    | public File(String pathname)             | 创建路径名实例                |
    | public File(String parent, String child) | 父+子路径 创建实例             |
    | public File(URI uri)                     | 根据URI 路径创建一个新的 File 实例 |
  
  - **MultipartFile类**
    
    该接口有多个方法属性
    
    | 参数                    | 描述     |
    | --------------------- | ------ |
    | getName()             | 文件格式   |
    | getOriginalFilename() | 文件名    |
    | getContentType        | 文件类型   |
    | isEmpty()             | 文件是否为空 |
    | getSize()             | 文件大小   |
  
  ```java
  @Override
      public List<File> getCurFiles(String dir,String id) {
          QueryWrapper<File> wrapper=new QueryWrapper<>();
          wrapper.eq("f_dir",dir);
          wrapper.eq("mem_id",id);
          //File files = baseMapper.selectById(wrapper);
          List<File> files = baseMapper.selectList(wrapper);
          return files;
      }
  
      @Override
      public File getFiles(String id) {
          QueryWrapper<File> wrapper=new QueryWrapper<>();
          wrapper.eq("id",id);
          File file = baseMapper.selectOne(wrapper);
          return file;
      }
  
      @Override
      public List<File> getFindFile(String memid,String name) {
          QueryWrapper<File> wrapper=new QueryWrapper<>();
          wrapper.eq("mem_id",memid);
          wrapper.like("name",name);
          List<File> fileList = baseMapper.selectList(wrapper);
          return fileList;
      }
  ```

- **对用户口令信息加密存储**
  
  **使用MD5加密来完成登录注册的验证**
  
  MD5加密全程是Message-Digest Algoorithm 5（信息-摘要算法），它对信息进行摘要采集，再通过一定的位运算，最终获取加密后的MD5字符串。
  
  MD5加密的特点主要有以下几点：
  
  1、针对不同长度待加密的数据、字符串等等，其都可以返回一个固定长度的MD5加密字符串。（通常32位的16进制字符串）
  2、其加密过程几乎不可逆，除非维护一个庞大的Key-Value数据库来进行碰撞破解，否则几乎无法解开。
  3、运算简便，且可实现方式多样，通过一定的处理方式也可以避免碰撞算法的破解。
  4、对于一个固定的字符串。数字等等，MD5加密后的字符串是固定的，也就是说不管MD5加密多少次，都是同样的结果。
  
  ```java
  //判断密码
          //因为存储到数据库密码肯定加密的
          //把输入的密码进行加密，再和数据库密码进行比较
          //加密方式 MD5
          if (!MD5.encrypt(password).equals(mobileMember.getPassword())) {
              throw new SpaceException(20001, "登录失败");
          }
          //登录成功
          //生成token字符串，使用jwt工具类
          String jwtToken = JwtUtils.getJwtToken(mobileMember.getId(), mobileMember.getNickname());
          QueryWrapper<UcenterMember> wrapper1=new QueryWrapper<>();
          wrapper1.eq("mobile",member.getMobile());
          UcenterMember ucenterMember = baseMapper.selectOne(wrapper1);
          return jwtToken;
      }
  ```

- **对上传文件大小进行限制**
  
  - 一般的web系统基本都会有文件上传功能，文件上传必然涉及到一个问题，就是文件大小，太大的文件不仅传输速度慢，而且对服务器压力巨大，后期的下载和保存都是一种考验。
  
  - 所以有了文件大小限制，一般我们在处理上传的接口时，其实就可以判断文件大小，这时候做一个大小判断，不符合要求，直接不保存文件，并返回前端相关提示。这种做法有一个不好的地方，就是如果上传方法重载，或者使用的地方不一样，那么每个方法都需要做这样的大小限制判断。
  
  - springboot使用MultipartFile上传，可以对文件上传大小做限制。直接配置如下所示：
    
    ```java
    spring.servlet.multipart.enabled=true
    spring.servlet.multipart.max-file-size=50MB
    spring.servlet.multipart.max-request-size=50MB
    ```
  
  - 这种设置，如果不做额外的处理，的确可以起到作用，但是如果你调用上传接口，上传过大文件，返回的结果可能如下所示：
    
    ```java
    {
        "timestamp": "2022-07-28T06:39:28.820+00:00",
        "status": 500,
        "error": "Internal Server Error",
        "path": "/test/upload"
    }
    ```
  
  - 这个是springboot通过拦截器做出的返回，而且后台还会打印异常信息。有时候，我们希望我们的返回信息跟我们其他的业务逻辑返回一样，就需要自定义一个返回。做法很简单，自定义一个BaseController，然后让上传的Controller来继承这个类即可。
    
    ```java
    package com.example.undertowtest.web;
    
    import io.undertow.server.handlers.form.MultiPartParserDefinition;
    import org.springframework.web.bind.annotation.ControllerAdvice;
    import org.springframework.web.bind.annotation.ExceptionHandler;
    import org.springframework.web.bind.annotation.ResponseBody;
    import org.springframework.web.multipart.MultipartException;
    
    import java.util.HashMap;
    import java.util.Map;
    
    @ControllerAdvice
    public class BaseController {
    ```

        @ResponseBody
        @ExceptionHandler(value = MultipartException.class)
        public Object fileUploadExceptionHandler(MultipartException exception){
            Map<String,Object> map = new HashMap<>();
            map.put("code",500);
            Throwable rootCause = exception.getRootCause();
            if(rootCause instanceof MultiPartParserDefinition.FileTooLargeException){
                map.put("msg","文件太大");
            }
            return map;
        }
    }
    ```

- **spring boot后端解决跨域问题的几种方法**
  
  - **1.使用注解** 
    
    在controller 类上加上@CrossOrigin注解，就能对该类下的接口进行跨域访问，从而解决跨域问题，但是这中方法在接口比较多的情况下是比较繁琐的，需要同时改动多个文件才能实现
  
  - **2.重写`addCorsMappings`方法**
    
    ![](https://s6.jpg.cm/2022/08/04/PdnhbQ.png)
    
    ```java
    @Configuration
    @EnableSwagger2
    public class SwaggerConfig {
    
        @Bean
        public Docket webApiConfig() {
            return new Docket(DocumentationType.SWAGGER_2)
                    .groupName("webApi")
                    .apiInfo(webApiInfo())
                    .select()
                    //.paths(Predicates.not(PathSelectors.regex("/admin/.*")))
                    .paths(Predicates.not(PathSelectors.regex("/error.*")))
                    .build();
    ```

### 网站部署和相关云服务技术使用

在完成以上前后端整体开发后，就需要将全部文件数据打包部署到线上，我们使用的是阿里云的服务，包括OSS对像存储用于文件存储，ECS云服务器部署网站，阿里的信息验证码服务，域名绑定。这也是我之前没有接触过的地方，所以在整个部署过程中也花费了大量的时间成本去学习和实践，虽然最后有部分服务的使用还存在限制，但整体已完成全部部署，也算是从头到尾浅尝了一遍阿里的云服务一条龙吧！😋

#### 服务器安装Nginx

Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用，我们的网站部署到Nginx服务器上。当然也可以选择其它web服务器，这里我们就使用主流的Nginx。

我在阿里云购买了ECS服务器，服务器是Centos系统，故已Centos为例。

##### <img src="https://s6.jpg.cm/2022/08/04/PdLDmr.png" style="zoom:50%;" />

安装nginx相关服务：

```bash
yum install -y nginx
```

查看nginx安装目录：

```bash
whereis nginx
```

或者使用命令查看nginx版本号，出现版本号也代表安装成功。

输入命令：

```bash
nginx -v
```

修改nginx配置

此时/etc/nginx则是nginx配置文件存放位置，进入该文件夹：

<img src="https://s6.jpg.cm/2022/08/04/PdPQTp.png" style="zoom:50%;" />

上面界面我们基本上不用改什么，重要的是server这个对象，可以看到默认监听的是80端口，所以我们直接访问服务器ip即可。

此时访问时则需要带上端口号（需要服务器安全组开启8080端口）

此时按照官方文档配置好服务器实例的安全组并启动：

<img src="https://s6.jpg.cm/2022/08/04/PdPed6.png" style="zoom:50%;" />

​    新建网站文件夹

​    设置了网站存放的文件夹路径为：

```bash
/home/www/dist
```

此时我们需要在服务器上新建www文件夹：

```bash
cd /home
mkdir www
```

此处我们还没有新建`dist`文件夹，因为我们还没有把vue项目打包，打包后才会生成`dist`文件夹。

#### 打包部署vue项目

打包网站

使用vue打包命令,生成dist文件夹：

```powershell
npm run build
```

<img src="https://s6.jpg.cm/2022/08/04/PdPlYT.png" style="zoom: 33%;" />

<img src="https://s6.jpg.cm/2022/08/04/PdPbA2.png" style="zoom:33%;" />

​    上传至服务器

​    我们可以使用ftp工具将dist文件夹上传至/home/www目录下，当然也可以使用命令：

```
scp -r dist/ root@119.23.64.32:/home/www
```

在我们的项目目录下用打开git命令行，将本地的dist整个文件夹复制到服务器，需要主要的时scp命令window不支持，所以使用了git命令行工具。

此时无需重启nginx，刷新浏览器，可以看到我们的网站已经部署成功了。

<img src="https://s6.jpg.cm/2022/08/04/PdPNCO.png" style="zoom: 33%;" />

#### 解决刷新路由404问题

当我们切换路由后，然后在刷新页面，会出现404的情况。

这是因为我们vue项目采用了history的路由方式，至于原因主要是vue是单页面应用,路由的切换会由于重复调用判定失效。

解决问题的办法：

（1）将路由模式改为hash

（2）修改nginx配置：

```powershell
location / {
  try_files $uri $uri/ /index.html; ---解决页面刷新404问题
}　
```

再次重启即可解决404问题

#### 后端SpringBoot框架打包部署

- SpringBoot项目我们本次使用的是Maven集成部署，其中需要加入相关的plugins信息，如下：
  
  - ```typescript
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <fork>true</fork>
                </configuration>
            </plugin>
        </plugins>
    </build>
    ```
    
    加入了上述信息至pom文件中
    
    在启动类加上`extends SpringBootServletInitializer`并重写`configure`方法。
    
    ```java
    @SpringBootApplication
    @ComponentScan(basePackages = {"com.chen"})
    @MapperScan("com.chen.service.mapper")
    public class AllApplication {
        public static void main(String[] args) {
            SpringApplication.run(AllApplication.class, args);
        }
    }
    ```
    
    就可以进行初步打包了，可以在Maven信息框中进行执行命令：
    
    ```java
    mvn clean package
    ```
    
    我们就可以在项目的target文件夹下得到一个jar包了
    
    ![](https://s6.jpg.cm/2022/08/04/PdP2GG.png)
    
    再将打包好的jar包部署到服务器端，执行命令，即可完成后端部署。
    
    ```bash
    java -jar *.jar
    ```

#### 域名DNS解析服务

我们首先在阿里云平台购置了域名：[cucinstall.cn](https://www.cucinstall.cn/)

完成个人信息验证后，进入DNS解析工作台配置域名解析服务，将域名绑定到项目的服务器ip地址

![](https://s6.jpg.cm/2022/08/04/PdPMGS.png)

ping一下域名，查看解析情况是否正常

![](https://s6.jpg.cm/2022/08/04/PdPOcW.png)

#### SSL证书申请和使用

我们本次使用了阿里云的SSL证书签发，采用的是RSA算法加密

![](https://s6.jpg.cm/2022/08/04/PdPZv2.png)

再在域名控制台对域名进行证书绑定

![](https://s6.jpg.cm/2022/08/04/PdREnT.png)

#### OSS存储文件使用

首先要开通ali-oss服务，并进行对应的配置，设立好需要的Bucket用来存储文件

<img src="https://s6.jpg.cm/2022/08/04/Pdq4uz.png" style="zoom:50%;" />

获得唯一的的Accesskey和对应的口令，配置在数据接口中，并与数据库进行同步

```typescript
/** 
*  上传文件，大小不能超过5GB 
* @param {string} ObjName OSS的储存路径和文件名字 
* @param {string} fileUrl 本地文件 
* @retruns Promise 
*/
export const put = async (ObjName, fileUrl) => {  
  try {    
    let result = await client.put(`${ObjName}`, fileUrl)    
    // ObjName为文件名字,可以只写名字，就直接储存在 bucket 的根路径，如需放在文件夹下面直接在文件名前面加上文件夹名称    
    return result  
  } catch (e) {    
   console.log(e)  
  }
}

// 上传成功之后，转换真实的地址
export const signatureUrl= async (ObjName) => {    
  try {        
    let result = await client.signatureUrl(`${ObjName}`)    
    return result  
  } catch (e) {    
    console.log(e)  
  }
}
```

![](https://s6.jpg.cm/2022/08/04/PdqBBu.png)

## 总结反思

上述对于整个项目的具体内容进行了一些回顾和总结，但在整个开发流程中，我们还存在部分技术细节和问题没有解决，我们也进行了很多的改进和尝试，但是最终实现还得需要一些时间去进一步学习和实践💡。

- **短信验证码服务**
  
  - 我的初步想法是通过手机号进行信息验证码的发送来完成用户信息的注册，我开通了阿里的短信发送服务，同时后端我也对用户的验证码信息服务进行了函数编写。
  
  - ```java
    public String login(UcenterMember member) {
            //获取登录手机号和密码
            String mobile = member.getMobile();
            String password = member.getPassword();
            System.out.println(mobile + password);
            //手机号和密码非空判断
            if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password)) {
                throw new SpaceException(20001, "登录失败");
            }
            //判断手机号是否正确
            QueryWrapper<UcenterMember> wrapper = new QueryWrapper<>();
            wrapper.eq("mobile", mobile);
            UcenterMember mobileMember = baseMapper.selectOne(wrapper);
            //判断查询对象是否为空
            if (mobileMember == null) {//没有这个手机号
                throw new SpaceException(20001, "登录失败");
            }
    ```
    
    再对用户的手机号是否重复，验证码的信息是否匹配进行筛选：
    
    ```java
    public UcenterMember login1(UcenterMember member) {
            //获取登录手机号和密码
            String mobile = member.getMobile();
            String password = member.getPassword();
            System.out.println(mobile + password);
            //手机号和密码非空判断
            if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password)) {
                throw new SpaceException(20001, "手机号或密码为空，登录失败");
            }
            //判断手机号是否正确
            QueryWrapper<UcenterMember> wrapper = new QueryWrapper<>();
            wrapper.eq("mobile", mobile);
            UcenterMember mobileMember = baseMapper.selectOne(wrapper);
            //判断查询对象是否为空
            if (mobileMember == null) {//没有这个手机号
                throw new SpaceException(20001, "未注册，登录失败");
            }
    
            //判断密码
            //因为存储到数据库密码肯定加密的
            //把输入的密码进行加密，再和数据库密码进行比较
            //加密方式 MD5
            if (!MD5.encrypt(password).equals(mobileMember.getPassword())) {
                throw new SpaceException(20001, "登录失败");
            }
            //登录成功
            //生成token字符串，使用jwt工具类
            //String jwtToken = JwtUtils.getJwtToken(mobileMember.getId(), mobileMember.getNickname());
            QueryWrapper<UcenterMember> wrapper1=new QueryWrapper<>();
            wrapper1.eq("mobile",member.getMobile());
            UcenterMember ucenterMember = baseMapper.selectOne(wrapper1);
            return ucenterMember;
        }
        //注册的方法
        public void register(RegisterVo registerVo) {
            //获取注册的数据
            String code = registerVo.getCode(); //验证码
            String mobile = registerVo.getMobile(); //手机号
            String nickname = registerVo.getNickname(); //昵称
            String password = registerVo.getPassword(); //密码
            String avatar=registerVo.getAvatar();//头像
            //非空判断
            if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password)
                    || StringUtils.isEmpty(code) || StringUtils.isEmpty(nickname)
                    ) {
                throw new SpaceException(20001, "不能为空");
            }
    //        判断验证码
            String redisCode = "1234";
            System.out.println(redisCode);
            if (!code.equals(redisCode)) {
                throw new SpaceException(20001, "验证码错误");
            }
    ```

            //判断手机号是否重复，表里面存在相同手机号不进行添加
            QueryWrapper<UcenterMember> wrapper = new QueryWrapper<>();
            wrapper.eq("mobile", mobile);
            Integer count = baseMapper.selectCount(wrapper);
            if (count > 0) {
                throw new SpaceException(20001, "手机号已存在，注册失败！");
            }
            //数据添加数据库中
            UcenterMember member = new UcenterMember();
            member.setMobile(mobile);
            member.setNickname(nickname);
            member.setAvatar(avatar);
            member.setPassword(MD5.encrypt(password));//密码需要加密的
            baseMapper.insert(member);
        }
    ```
    
    虽然在本地测试是可以的，但是阿里的信息验证服务要求必须提供网站或者AppID，导致我无法模拟发送验证码，这个地方尝试了很多方案，只能在本地跑通，而部署到线上，因为网站本身没有获得备案号和ID，所以最终无法去实现验证码信息发送服务，只能在后端的验证码输入框指定规定数字，这确实影响到了整个注册流程，这也是后续需要去想办法改进的地方。

- **文件数字签名功能**
  
  - 在对于上传文件进行数字签名这个地方，我们进行了诸多方案的尝试，其中我们初步思路是采用了OpenSSl生成RSA私钥去进行身份的验证
  
  - ```powershell
    #用 OpenSSL， Linux 上自带，常用命令如下：
    #生成 RSA 私钥（传统格式的）
    openssl genrsa -out rsa_private_key.pem 1024
    #将传统格式的私钥转换成 PKCS#8 格式的（JAVA需要使用的私钥需要经过PKCS#8编码，PHP程序不需要，可以直接略过）
    openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt
    #生成 RSA 公钥
    openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem
    ```
  
  - ​    使用私钥对文件进行加签、并验证
    
    ```bash
    #有明文文件file.txt和RSA密钥rsa_private_key.pem
    #使用md5指令指定sha1算法，对file.txt进行签名，生成签名文件sign1.txt
    openssl md5 -sha512 -sign rsa_private_key.pem -out data_xinbao.tar.gz.sign data_xinbao.tar.gz
    #使用md5指令指定sha1算法，对file.txt进行签名，生成签名文件sign1.txt
    openssl dgst -sha512 -sign rsa_private_key.pem -out data_xinbao.tar.gz.sign data_xinbao.tar.gz
    #两个签名文件一样，说明两个指令完成相同的功能
    diff data_xinbao.tar.gz.sign data_xinbao1.tar.gz.sign
    #使用RSA公钥验证签名(verify参数)，验证成功
    openssl md5 -verify rsa_public_key.pem -sha512 -signature data_xinbao1.tar.gz.sign data_xinbao.tar.gz
    openssl dgst -verify rsa_public_key.pem -sha512 -signature data_xinbao.tar.gz.sign data_xinbao.tar.gz
    ```
    
    拿加签的原文件和加签后的文件使用Java代码进行对比；
    
    ```java
    public class RsaEncrypt {
        /**
         * rsa签名
         * @param data  待签名的字符串
         * @param priKey  rsa私钥字符串
         * @return 签名结果
         * @throws Exception    签名失败则抛出异常
         */
        public byte[] rsaSign(byte[] data, RSAPrivateKey priKey)
                throws SignatureException {
            try {
                Signature signature = Signature.getInstance("SHA512withRSA");
                signature.initSign(priKey);
                signature.update(data);
    
                byte[] signed = signature.sign();
                return signed;
            } catch (Exception e) {
                throw new SignatureException("RSAcontent = " + data
                        + "; charset = ", e);
            }
        }
    
        /**
         * rsa验签
         * @param data  被签名的内容
         * @param sign   签名后的结果
         * @param pubKey   rsa公钥
         * @return 验签结果
         * @throws SignatureException 验签失败，则抛异常
         */
        public boolean verify(byte[] data, byte[] sign, RSAPublicKey pubKey)
                throws SignatureException {
            try {
                Signature signature = Signature.getInstance("SHA512withRSA");
                signature.initVerify(pubKey);
                signature.update(data);
                return signature.verify(sign);
    
            } catch (Exception e) {
                e.printStackTrace();
                throw new SignatureException("RSA验证签名[content = " + data
                        + "; charset = " + "; signature = " + sign + "]发生异常!", e);
            }
        }
    
        /**
         * 私钥
         */
        private RSAPrivateKey privateKey;
    
        /**
         * 公钥
         */
        private RSAPublicKey publicKey;
    
        /**
         * 字节数据转字符串专用集合
         */
        private static final char[] HEX_CHAR = { '0', '1', '2', '3', '4', '5', '6',
                '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
    
        /**
         * 获取私钥
         * @return 当前的私钥对象
         */
        public RSAPrivateKey getPrivateKey() {
            return privateKey;
        }
    
        /**
         * 获取公钥
         * @return 当前的公钥对象
         */
        public RSAPublicKey getPublicKey() {
            return publicKey;
        }
    
        /**
         * 随机生成密钥对
         */
        public void genKeyPair() {
            KeyPairGenerator keyPairGen = null;
            try {
                keyPairGen = KeyPairGenerator.getInstance("RSA");
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            }
            keyPairGen.initialize(1024, new SecureRandom());
            KeyPair keyPair = keyPairGen.generateKeyPair();
            this.privateKey = (RSAPrivateKey) keyPair.getPrivate();
            this.publicKey = (RSAPublicKey) keyPair.getPublic();
        }
    
        /**
         * 从.pem文件中取得私钥
         * @param filePath 文件路径
         * @return 私钥
         */
        public String getPrivateKeyFromFile(String filePath){
            String strPrivateKey = "";
            try {
                BufferedReader privateKey = new BufferedReader(new FileReader(filePath));
                String line = "";
                while((line = privateKey.readLine()) != null){
                    strPrivateKey += line;
                }
                privateKey.close();
                strPrivateKey = strPrivateKey.replace("-----BEGIN PRIVATE KEY-----","").replace("-----END PRIVATE KEY-----","");
            }catch (Exception e){
                e.printStackTrace();
            }
            return strPrivateKey;
        }
    
        /**
         * 从.pem文件中取得公钥
         * @param filePath 文件路径
         * @return 公钥
         */
        public String getPublicKeyFromFile(String filePath){
            String strPublicKey = "";
            try {
                BufferedReader publicKey = new BufferedReader(new FileReader(filePath));
                String line = "";
                while((line = publicKey.readLine()) != null){
                    strPublicKey += line;
                }
                publicKey.close();
                strPublicKey = strPublicKey.replace("-----BEGIN PUBLIC KEY-----","").replace("-----END PUBLIC KEY-----","");
            }catch (Exception e){
                e.printStackTrace();
            }
            return strPublicKey;
        }
    
        /**
         * 从字符串中加载公钥
         * @param publicKeyStr 公钥数据字符串
         * @throws Exception 加载公钥时产生的异常
         */
        public void loadPublicKey(String publicKeyStr) throws Exception {
            try {
                byte[] buffer = Base64Utils.decode(publicKeyStr);
                KeyFactory keyFactory = KeyFactory.getInstance("RSA");
                X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);
                this.publicKey = (RSAPublicKey) keyFactory.generatePublic(keySpec);
            } catch (NoSuchAlgorithmException e) {
                throw new Exception("无此算法");
            } catch (InvalidKeySpecException e) {
                throw new Exception("公钥非法");
            }catch (NullPointerException e) {
                throw new Exception("公钥数据为空");
            }
        }
    
        /**
         * 加载私钥
         * @param privateKeyStr 私钥文件名
         * @return 是否成功
         * @throws Exception
         */
        public void loadPrivateKey(String privateKeyStr) throws Exception {
            try {
                byte[] buffer = Base64Utils.decode(privateKeyStr);
                PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(buffer);
                KeyFactory keyFactory = KeyFactory.getInstance("RSA");
                this.privateKey = (RSAPrivateKey) keyFactory.generatePrivate(keySpec);
            } catch (NoSuchAlgorithmException e) {
                throw new Exception("无此算法");
            } catch (InvalidKeySpecException e) {
                throw new Exception("私钥非法");
            } catch (NullPointerException e) {
                throw new Exception("私钥数据为空");
            }
        }
    
        /**
         * 加密过程
         * @param publicKey 公钥
         * @param plainTextData 明文数据
         * @return
         * @throws Exception 加密过程中的异常信息
         */
        public byte[] encrypt(RSAPublicKey publicKey, byte[] plainTextData)
                throws Exception {
            if (publicKey == null) {
                throw new Exception("加密公钥为空, 请设置");
            }
            Cipher cipher = null;
            try {
                cipher = Cipher.getInstance("RSA");
                cipher.init(Cipher.ENCRYPT_MODE, publicKey);
                byte[] output = cipher.doFinal(plainTextData);
                return output;
            } catch (NoSuchAlgorithmException e) {
                throw new Exception("无此加密算法");
            } catch (NoSuchPaddingException e) {
                e.printStackTrace();
                return null;
            } catch (InvalidKeyException e) {
                throw new Exception("加密公钥非法,请检查");
            } catch (IllegalBlockSizeException e) {
                throw new Exception("明文长度非法");
            } catch (BadPaddingException e) {
                throw new Exception("明文数据已损坏");
            }
        }
    
        /**
         * 解密过程
         * @param privateKey 私钥
         * @param cipherData 密文数据
         * @return 明文
         * @throws Exception   解密过程中的异常信息
         */
        public byte[] decrypt(RSAPrivateKey privateKey, byte[] cipherData)
                throws Exception {
            if (privateKey == null) {
                throw new Exception("解密私钥为空, 请设置");
            }
            Cipher cipher = null;
            try {
                cipher = Cipher.getInstance("RSA");
                cipher.init(Cipher.DECRYPT_MODE, privateKey);
                byte[] output = cipher.doFinal(cipherData);
                return output;
            } catch (NoSuchAlgorithmException e) {
                throw new Exception("无此解密算法");
            } catch (NoSuchPaddingException e) {
                e.printStackTrace();
                return null;
            } catch (InvalidKeyException e) {
                throw new Exception("解密私钥非法,请检查");
            } catch (IllegalBlockSizeException e) {
                throw new Exception("密文长度非法");
            } catch (BadPaddingException e) {
                throw new Exception("密文数据已损坏");
            }
        }
    
        /**
         * 字节数据转十六进制字符串
         * @param data  输入数据
         * @return 十六进制内容
         */
        public static String byteArrayToString(byte[] data) {
            StringBuilder stringBuilder = new StringBuilder();
            for (int i = 0; i < data.length; i++) {
                // 取出字节的高四位 作为索引得到相应的十六进制标识符 注意无符号右移
                stringBuilder.append(HEX_CHAR[(data[i] & 0xf0) >>> 4]);
                // 取出字节的低四位 作为索引得到相应的十六进制标识符
                stringBuilder.append(HEX_CHAR[(data[i] & 0x0f)]);
                if (i < data.length - 1) {
                    stringBuilder.append(' ');
                }
            }
            return stringBuilder.toString();
        }
    
        /**
         * btye转换hex函数
         * @param byteArray
         * @return
         */
        public static String byteToHex(byte[] byteArray) {
            StringBuffer strBuff = new StringBuffer();
            for (int i = 0; i < byteArray.length; i++) {
                if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) {
                    strBuff.append("0").append(
                            Integer.toHexString(0xFF & byteArray[i]));
                } else {
                    strBuff.append(Integer.toHexString(0xFF & byteArray[i]));
                }
            }
            return strBuff.toString();
        }
    
        /**
         * 以字节为单位读取文件，常用于读二进制文件，如图片、声音、影像等文件。
         */
        public static byte[] readFileByBytes(String fileName) {
            File file = new File(fileName);
            InputStream in = null;
            byte[] txt = new byte[(int) file.length()];
            try {
                // 一次读一个字节
                in = new FileInputStream(file);
                int tempbyte;
                int i = 0;
                while ((tempbyte = in.read()) != -1) {
                    txt[i] = (byte) tempbyte;
                    i++;
                }
                in.close();
                return txt;
            } catch (IOException e) {
                e.printStackTrace();
                return txt;
            }
        }
    
        /**
         * Main 测试方法
         * @param args
         */
        public static void main(String[] args) {
            RsaEncrypt rsaEncrypt = new RsaEncrypt();
            try {
                String publicKey = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDPTrsUJ26WDSEQwKuAJhQ6XTNHKl1/+bWeyKRQKb0jeCyuiChMxN/qYSgg2BvS2bP51Rb5P9/UE1Rxm5drr3RYNMDvQoXBuA+rHiUX3wkdXmWSaktVbfe5C95N5FCF2jyLMIuWmrMk6Wo3r5MXrCb54A6zU7SzO/r7F0VkpBh9KwIDAQAB";
                rsaEncrypt.loadPublicKey(publicKey);
                System.out.println("加载公钥成功");
            } catch (Exception e) {
                System.err.println(e.getMessage());
                System.err.println("加载公钥失败");
            }
            // 加载私钥
            try {
                String privateKey = "MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAM9OuxQnbpYNIRDAq4AmFDpdM0cqXX/5tZ7IpFApvSN4LK6IKEzE3+phKCDYG9LZs/nVFvk/39QTVHGbl2uvdFg0wO9ChcG4D6seJRffCR1eZZJqS1Vt97kL3k3kUIXaPIswi5aasyTpajevkxesJvngDrNTtLM7+vsXRWSkGH0rAgMBAAECgYAlnFEQnP7RNlyTX4E95Kqy1AnjlWoVN8adoiU9bfUkpD7nA0jcdLNzIGFZZBvYKysd3m0ml1ISdddSLTpRjSl8K6O9dJDud3G9Oh3qCGgFflcKuKEXDnlaooX1sBrWF5vS0Gvg98x2C52Pnblm2eGVuTvCMaINDZLaamUlaFldMQJBAO3clhAIBJSWlm7Tt/a1d7+IbsGcS16Rk/N23DHg6LADXxIezxgSrpztSa5Nq81W5RC2WsotYYeRt+8KHsPRRn8CQQDfHa7A7hBTOT/V4FXTApuJUlReUh6cHWPsrxf/rUYKylK9WYBAJv1AZW9KaRtcadyu7ldNMb3MAsbE2vLoW2tVAkEAxhvLAF8tMXSapoO/3MMXkXbYiHjcbU9iooyEqSZhpven3ze51Jr6w8j+bSZTyRpufpTi2TEi4f8D6xvKs91BkQJBAKLS05xiX7GMfwSDQb7LEVzmo0FuJn6BiFHK+fWRqyLmwfkDHvAyQ/FB1TT1fY00iGN09msUWNFQWWSB8HEXfj0CQQCAJYV35rNJ781DXhBH5m1tq74zDNzAqynjm0hqhzlVMSHTYFIeU6SBnhk3swnfvJ8kgy3bQJtohYZ8Tuaz19VN";
                rsaEncrypt.loadPrivateKey(privateKey);
                System.out.println("加载私钥成功");
            } catch (Exception e) {
                System.err.println(e.getMessage());
                System.err.println("加载私钥失败");
            }
            // 测试字符串
            String encryptStr = "12321dsfasf1321312fsfdsafsdafasfsadf";
            try {
                System.out.println(new Date());
                // 加密
                byte[] cipher = rsaEncrypt.encrypt(rsaEncrypt.getPublicKey(),
                        encryptStr.getBytes());
                // 解密
                byte[] plainText = rsaEncrypt.decrypt(rsaEncrypt.getPrivateKey(),
                        cipher);
                System.out.println(new Date());
                System.out.println(new String(plainText));
                byte[] content = readFileByBytes("/data/zhnx/IN/data_xinbao.tar.gz");
                // 签名验证
                byte[] signbyte = rsaEncrypt.rsaSign(content, rsaEncrypt.getPrivateKey());
                System.out.println("签名-----：" + byteToHex(signbyte));
                ByteUtil.saveFile(signbyte,"/data/zhnx/IN/","data_xinbao1.tar.gz.sign");
                Boolean isok = rsaEncrypt.verify(content, signbyte, rsaEncrypt.getPublicKey());
                System.out.println("验证：" + isok);
    
                // 读取验证文件
                byte[] read = readFileByBytes("/data/zhnx/IN/data_xinbao.tar.gz.sign");
                System.out.println("读取签名文件：" + byteToHex(read));
                Boolean isfok = rsaEncrypt.verify(content, read, rsaEncrypt.getPublicKey());
                System.out.println("文件验证2：" + isfok);
    
            } catch (Exception e) {
                System.err.println(e.getMessage());
            }
        }
    }
    ```
    
    将最终需要验证的文件格式同源文件进行对比验证来达到数字签名的身份验证功能，但是在实际的开发过程中，由于我们系统接受多种文件格式，导致在音频文件、视频文件、压缩包等文件在进行解析过程中总是会出现解析错误而导致乱码，最终使得在数字签名加密后从后端返回的数据无法正确解析而无法读取，于是我们只能暂时注释了这一段代码。
    
    于是我们换了另一种方案去实现用户访问权限和文件加密，通过用户自行设定某个口令，作为用户上传数据data部分的`accesskey`，通过DES加密来实现对文件数据的加密和访问，包括对于文件的下载、打开、删除进行访问权限的控制。
    
    ```java
    * 加密
         *
         * @param datasource byte[]
         * @param password   String
         * @return byte[]
         */
        public static byte[] encrypt(byte[] datasource, String password) {
            try {
                SecureRandom random = new SecureRandom();
                DESKeySpec desKey = new DESKeySpec(password.getBytes());
                // 创建一个密匙工厂，然后用它把DESKeySpec转换成
                SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
                SecretKey securekey = keyFactory.generateSecret(desKey);
                // Cipher对象实际完成加密操作
                Cipher cipher = Cipher.getInstance("DES");
                // 用密匙初始化Cipher对象
                cipher.init(Cipher.ENCRYPT_MODE, securekey, random);
                // 现在，获取数据并加密
                // 正式执行加密操作
                return cipher.doFinal(datasource);
            } catch (Throwable e) {
                e.printStackTrace();
            }
            return null;
        }
        /**
         * 解密
         *
         * @param src      byte[]
         * @param password String
         * @return byte[]
         * @throws Exception
         */
        public static byte[] decrypt(byte[] src, String password) throws Exception {
            // DES算法要求有一个可信任的随机数源
            SecureRandom random = new SecureRandom();
            // 创建一个DESKeySpec对象
            DESKeySpec desKey = new DESKeySpec(password.getBytes());
            // 创建一个密匙工厂
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
            // 将DESKeySpec对象转换成SecretKey对象
            SecretKey securekey = keyFactory.generateSecret(desKey);
            // Cipher对象实际完成解密操作
            Cipher cipher = Cipher.getInstance("DES");
            // 用密匙初始化Cipher对象
            cipher.init(Cipher.DECRYPT_MODE, securekey, random);
            // 真正开始解密操作
            return cipher.doFinal(src);
        }
    }
    ```
  
  - ![](https://s6.jpg.cm/2022/08/04/Pd8QID.png)

## 参考资料

- [Vue.js使用文档](https://cn.vuejs.org/v2/guide/)
- [SpringBoot使用文档](https://spring.io/guides)
- [ElementUI使用文档](https://element.eleme.cn/#/zh-CN/component/installation)
- [Setting global sass variables in a vue project](https://stackoverflow.com/questions/53686780/setting-global-sass-variables-in-a-vue-project)
- [Encrypt password in front with Vue JS](https://www.anycodings.com/questions/encrypt-password-in-front-with-vue-js)
- [Implementation of music playback component in vue](https://dev.to/jordanirabor/music-and-video-player-with-vuejs--day-2--3-30-days-of-code-c24)
- [vue uses axios to pass parameters](https://stackoverflow.com/questions/53709142/best-way-to-pass-query-parameters-to-url-using-axios-in-vue)
- [Address Resolution in DNS (Domain Name Server)](https://www.geeksforgeeks.org/address-resolution-in-dns-domain-name-server/)
- [How to deploy vue project](https://cli.vuejs.org/guide/deployment.html)
- [Styling Vue components with CSS](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_styling)
- [Ways to make component styles globally responsive in vue](https://vuejs.org/guide/essentials/component-basics.html)
- [Generating a Digital Signature for Java](https://docs.oracle.com/javase/tutorial/security/apisign/gensig.html)
- [ECS云服务器操作手册](https://help.aliyun.com/document_detail/42956.html)
- [MD5 Hashing in Java](https://www.baeldung.com/java-md5)
- [Spring Boot File upload example with Multipart File](https://www.bezkoder.com/spring-boot-file-upload/)
- [Vue realizes online preview of video files](https://vuejs.org/guide/scaling-up/sfc.html)
- [Data encryption basic algorithms: Java implementation](https://www.alirookie.com/post/data-encryption-basic-algorithms-java-implementation)
- [vue-router route encryption (without webpack) for security](https://stackoverflow.com/questions/56003782/vue-router-route-encryption-without-webpack-for-security)